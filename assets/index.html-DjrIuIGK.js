import{_ as i,c as t,f as a,o as n}from"./app-_cZTuvS3.js";const l={};function p(e,s){return n(),t("div",null,s[0]||(s[0]=[a(`<p><strong>浏览器可以同时打开多个同域名页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？</strong></p><p>端口一样的，网络进程知道每个TCP连接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。</p><p><strong>TCP传送数据时，浏览器端就做渲染处理了么？如果前面数据包丢了，后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？</strong></p><p>接收到http响应头中的content-type类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做DOM解析了！基于http不用担心数据包丢失的问题，因为丢包和重传都是在tcp层解决的。http能保证数据按照顺序接收的（也就是说，从tcp到http的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）</p><p><strong>http 和 websocket都是属于应用层的协议吗？</strong></p><p>都是应用层协议，而且websocket名字取的比较有迷惑性，其实和socket完全不一样，可以把websocket看出是http的改造版本，增加了服务器向客户端主动发送消息的能力。</p><p><strong>建立一个tcp连接，可以处理多个请求吗？</strong></p><p>http/1.1 一个tcp同时只能处理一个请求，浏览器会为每个域名维护6个tcp连接！</p><p>但是每个tcp连接是可以复用的，也就是处理完一个请求之后，不断开这个tcp连接，可以用来处理下个http请求！</p><p>不过http2是可以并行请求资源的，所以如果使用http2，浏览器只会为每个域名维护一个tcp连接。</p><p><strong>http2同个域名只能维持一个长连接。那我现在打开了一个域名下的a页面，然后又打开了这个域名的b页面，那这个b页面是新开一个tcp长连接吗？还是会用a页面的长连接？</strong></p><p>浏览器为用同一个域名只维护一个TCP连接。</p><p>通过Chrome打开<code>chrome://net-export/ </code>这个地址，然后记录网络过程。</p><p>最后在使用这个<code>https://netlog-viewer.appspot.com/ </code>打开你日志文件，就能看到h2的详细信息了。</p><p><strong>http的keep alive和http2中的信道复用有什么区别？</strong></p><p>一个http中的keep-alive是排队请求，也就是一个http请求完成之后才能继续请求下一个，而http2中请求是并发的，可以同时处理很多请求！</p><p><strong>浏览器请求页面时，各个进程间是怎么配合的？</strong></p><ol><li>用户输入url并回车。</li><li>用户输入URL，<strong>浏览器进程</strong>会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，<strong>浏览器进程</strong>就会根据URL协议，在这段内容上加上协议合成合法的URL。</li><li>浏览器导航栏显示loading状态，但是页面还是呈现之前的页面不变，因为新页面的响应数据还没有获得。</li><li><strong>浏览器进程</strong>构建请求行信息，通过进程间通信（IPC）把url请求发送给<strong>网络进程</strong></li><li><strong>网络进程</strong>接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给<strong>浏览器进程</strong></li><li>如果没有，<strong>网络进程</strong>向web服务器发起http请求（网络请求），请求流程如下： <ol><li>进行DNS解析，获取服务器ip地址</li><li>利用ip地址和服务器建立tcp连接</li><li>完成构建请求信息并发送请求</li><li>服务器响应后，<strong>网络进程</strong>接收响应头和响应信息，并解析响应内容</li></ol></li><li><strong>网络进程</strong>解析响应流程： <ol><li>检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步，如果是200，则继续处理请求。</li><li>检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html等资源则将其转发给<strong>浏览器进程</strong>。</li></ol></li><li><strong>浏览器进程</strong>接收到网络进程的响应头数据之后，检查当前url是否和<strong>之前打开的渲染进程</strong>根域名是否相同，如果相同，则复用原来的进程，如果不同，则<strong>开启新的渲染进程</strong>。</li><li><strong>渲染进程</strong>准备好后，<strong>浏览器进程</strong>发送<code>CommitNavigation</code>消息到<strong>渲染进程</strong>，发送<code>CommitNavigation</code>时会携带响应头、等基本信息。<strong>渲染进程</strong>接收到消息和<strong>网络进程</strong>建立传输数据的“管道”。</li><li><strong>渲染进程</strong>接收完数据后，向<strong>浏览器进程</strong>发送“确认提交”。</li><li><strong>浏览器进程</strong>接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</li></ol><p><strong>浏览器的http的keepalive是什么复用程度？</strong></p><p>首先keep-alive是为了解决连接效率不高的问题，http1.0时代，http请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接，通常，建立连接和断开连接的时间就有可能超过传输数据的时间了，这种短连接的效率是异常的低效。</p><p>针对短连接低效的问题，后面就出现了长连接，也就是这里要讲的keep-alive。</p><p>你可以把长连接看成是一个管道，一个http请求结束之后，不会关闭连接，下个请求可以复用该连接，这样就省去建立连接和断开连接的时间了，但是他们请求是按照顺序，也就是符合IP+端口规则的资源都可以复用该连接，这就回答了上面提的这个问题。</p><p>但是，使用keep-alive同样存在问题，比如一个页面可能有100张图片素材，假设这些图片素材都保存在同一个域名下面，如果只复用一个http管道的话，那么传输100张图片的素材也是非常耗时间的，这就出现了同一时刻并发连接服务器的需求，也就是文中提到同一时刻，对同一域名下面，只能可以发起6个请求，这样就可以大大提升请求效率了。</p><p>为什么是6个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。</p><p><strong>如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？</strong></p><p>当从服务器接收HTML页面的第一批数据时，DOM解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">    极客时间         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">      document</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">write</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">--foo</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下解析。 那么第二种情况复杂点了，我们内联的脚本替换成js外部文件，如下所示：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     极客时间         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">     &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> type</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">text/javascript</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> src</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">foo.js</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM渲染。 我们再看第三种情况，还是看下面代码：</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">style</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> type</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">text/css</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> src</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">theme.css</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> &gt;&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">style</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">head</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  	&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">极客时间</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">p</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  	&lt;</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">      let</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> document</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getElementsByTagName</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">p</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">             </span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">      e</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">style</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">color</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">blue</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">         </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">    &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">script</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;     </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  &lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">body</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> </span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;/</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">html</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。</p><p><strong>浏览器的渲染流程是什么？</strong></p><ol><li>渲染进程将 HTML 内容转换为能够读懂的 <strong>DOM 树</strong>结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 <strong>styleSheets</strong>，计算出 DOM 节点的样式。</li><li>创建<strong>布局树</strong>，并计算元素的布局信息。</li><li>对布局树进行分层，并生成<strong>分层树</strong>。</li><li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li><li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li><li>合成线程发送绘制图块命令 <strong>DrawQuad</strong> 给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上。</li></ol><p><strong>为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？</strong></p><p>重排需要更新完整的渲染流水线，所以开销也是最大的。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。使用 CSS 的 transform 来实现动画效果，可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。</p><p>减少重排重绘, 方法很多：</p><ol><li>使用 class 操作样式，而不是频繁操作 style</li><li>避免使用 table 布局</li><li>批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React</li><li>Debounce window resize 事件</li><li>对 dom 属性的读写要分离</li><li>will-change: transform 做优化</li></ol><p><strong>渲染进程里的input标签上传图片，通过与浏览器主进程通信，主进程读取硬磁盘图片数据返回给渲染进程，渲染进程里的js发起ajax请求，是通过浏览器主进程去调用网络进程发起请求，还是渲染进程可以直接调用网络进程发起请求？</strong></p><p><code>XMLHttpRequest</code> 可以直接走网络进程，不需要浏览器进程介入。</p><p><strong>请求长时间处于pending状态或者脚本执行死循环，这时刷新或前进后退页面不响应，刷新或前进后退页面是属于浏览器主进程的UI交互行为，为什么渲染进程里的js引擎执行会影响到主进程？</strong></p><p>因为前进或者后退也需要执行当前页面脚本，比如要执行<code>beforeunload</code>事件，执行的时候页面没响应了，所以前进后退也就失效了。</p><p><strong>V8编译的基本单位是一段JS代码（内敛JS）或者一个JS文件吗(还是以当前调用栈将要执行函数为单位）？</strong></p><p>全局代码，或者函数 ！</p><p>比如下载完一个js文件，先编译这个js文件，但是js文件内定义的函数是不会编译的。</p><p>等调用到该函数的时候，Javascript引擎才会去编译该函数！</p><p><strong>为什么代码执行时间越长，执行效率越高？</strong></p><p>随着v8执行，热点代码会越来越来越多，<code>turbofan</code>将热点代码转换为机器码，以哈希表形式存在堆内存中的，会占据越来越多的内存。</p><p><strong>为什么用CSS3实现动画效率会比JS实现来的高？</strong></p><p>部分css3的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重排和重绘的过程，这就大大提升了渲染效率。</p><p>JavaScript都是在在主线程上执行的，所以JavaScript的动画需要主线程的参与，所以效率会大打折扣！</p><p><strong>为什么渲染进程中有多个线程在工作，却说JS是单线程的呢？</strong></p><p>虽然浏览器是基于多进程+多线程架构的，但是JavaScript引擎是运行在渲染进程的主线程上的，所以我们说JavaScript是单线程执行的！</p><p><strong>浏览器的事件循环和js event loop是一回事吗？</strong></p><p>JavaScript没有自己循环系统，它依赖的就是浏览器的循环系统，也就是渲染进程提供的循环系统！所以可以说是一回事。</p><p><strong>渲染进程的主线程和V8执行机主线程是同一个线程吗？一个渲染进程有几个线程，分别有啥作用？</strong></p><p>主要有IO线程，用开负责和其它进程IPC通信的，然后主线程主要跑页面的！</p><p>V8是在主线程上执行的，因为dom操作啥的都是在主线程上执行的。</p><p>当然还有其它很多辅助线程，比如预解析DOM的线程，垃圾回收也有一些辅助线程。</p>`,59)]))}const k=i(l,[["render",p],["__file","index.html.vue"]]),r=JSON.parse('{"path":"/article/3wps6fp6/","title":"浏览器问题","lang":"zh-CN","frontmatter":{"title":"浏览器问题","tags":["面试"],"createTime":"2021/11/07","permalink":"/article/3wps6fp6/","description":"浏览器可以同时打开多个同域名页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？ 端口一样的，网络进程知道每个TCP连接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。 TCP传送数据时，浏览器端就做渲染处理了么？如果前面数据包丢了，后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？ 接收到http响应头中...","head":[["meta",{"property":"og:url","content":"https://jyqwq.github.io/rainbow/article/3wps6fp6/"}],["meta",{"property":"og:site_name","content":"纸上的彩虹"}],["meta",{"property":"og:title","content":"浏览器问题"}],["meta",{"property":"og:description","content":"浏览器可以同时打开多个同域名页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？ 端口一样的，网络进程知道每个TCP连接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。 TCP传送数据时，浏览器端就做渲染处理了么？如果前面数据包丢了，后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？ 接收到http响应头中..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-03T09:57:32.000Z"}],["meta",{"property":"article:tag","content":"面试"}],["meta",{"property":"article:modified_time","content":"2024-12-03T09:57:32.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浏览器问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-12-03T09:57:32.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":11.4,"words":3419},"git":{"updatedTime":1733219852000,"contributors":[{"name":"yuan.ji","email":"yuan.ji@ly.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yuan.ji?v=4","url":"https://github.com/yuan.ji"}]},"autoDesc":true,"filePathRelative":"日常学习/浏览器问题.md","categoryList":[{"id":"9a91b4","sort":10004,"name":"日常学习"}],"bulletin":false}');export{k as comp,r as data};
