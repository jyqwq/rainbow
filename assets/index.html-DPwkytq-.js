import{_ as a,c as n,f as e,o as p}from"./app-t7sSfxVc.js";const i={};function l(c,s){return p(),n("div",null,s[0]||(s[0]=[e(`<h2 id="检测点-1-1" tabindex="-1"><a class="header-anchor" href="#检测点-1-1"><span>检测点 1.1</span></a></h2><p>（1）1个CPU的寻址能力为8KB，那么它的地址总线的宽度是 <u>13</u>。</p><p><code>一个内存单元是1B，一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。8KB=8*2^10B=2^3*2^10B=2^13B,N=13</code></p><p>（2）1KB的存储器有 <u>1024</u> 个存储单元。存储单元的编号从 <u>0</u> 到 <u>1023</u>。</p><p><code>一个存储单元可以存储8bit，即8位二进制数。1B=8bit，1KB=1024B </code></p><p>（3）1KB的存储器可以存储 <u>8192</u> 个bit， <u>1024</u>个Byte。</p><p>（4）1GB、1MB、1KB分别是 <u>2<sup>30&lt;/u&gt;,&lt;u&gt;2</sup>20</u>,<u>2^10</u>个Byte。</p><p><code>1GB=1024MB,1MB=1024KB,1KB=1024B</code></p><p>（5）8080，8088，80286，80386的地址总线宽度分别是16根、20根、24根、32根，则它们的寻址能力分别是 <u>64</u>（KB）、 <u>1</u>（MB）、<u>16</u>（MB）、 <u>4</u>（GB）。</p><p>（6）8080、8088、8086、80286、80386的数据总线宽度分别是8根、8根、16根、16根、32根。则它们可以传送的数据为 <u>1</u>（B）、 <u>1</u>（B）、 <u>2</u>（B）、 <u>2</u>（B）、 <u>4</u>（B）。</p><p><code>一根=1bit，1bit是一个二进制</code></p><p>（7）从内存中读取1024字节的数据，8086至少要读 <u>512</u>次，80386至少要读 <u>256</u>次。</p><p><code>8086有16根数据线，每次读2B，80386有32根数据线，每次读4B</code></p><p>（8）在存储器中，数据和程序以 <u>二进制</u>形式存放。</p><p><code>在存储器中指令和数据没有任何区别，都是二进制</code></p><h1 id="第二章-寄存器" tabindex="-1"><a class="header-anchor" href="#第二章-寄存器"><span>第二章 寄存器</span></a></h1><h2 id="检测点-2-1" tabindex="-1"><a class="header-anchor" href="#检测点-2-1"><span>检测点 2.1</span></a></h2><p>（1）写出每条汇编指令执行后相关寄存器中的值。</p><p>mov ax,62627 <code>62627转十六进制，F4A3H，赋值给AX</code> AX= <u>F4A3H</u></p><p>mov ah,31H <code>AX的高八位换成31H</code> AX= <u>31A3H</u></p><p>mov al,23H <code>AX的低八位换成23H</code> AX= <u>3123H</u></p><p>add ax,ax <code>AX加上AX</code> AX= <u>6246H</u></p><p>mov bx,826CH <code>826CH赋值给BX</code> BX= <u>826CH</u></p><p>mov cx,ax <code>AX赋值给CX</code> CX= <u>6246H</u></p><p>mov ax,bx <code>BX赋值给AX</code> AX= <u>826CH</u></p><p>add ax,bx <code>AX加上BX存入AX</code> AX= <u>04D8H</u></p><p>mov al,bh <code>BX的高八位赋值给AX的低八位</code> AX= <u>0482H</u></p><p>mov ah,bl <code>BX的低八位赋值给AX的高八位</code> AX= <u>6C82H</u></p><p>add ah,ah <code>AX的高八位加上AX的高八位</code> AX= <u>D882H</u></p><p>add al,6 <code>AX的低八位加上6</code> AX= <u>D888H</u></p><p>add al,al  <code>AX的低八位加上AX的低八位</code> AX= <u>D810H</u></p><p>mov ax,cx <code>CX赋值给AX</code> AX= <u>6246H</u></p><p>（2）只能使用目前学过的汇编指令，最多使用四条指令，编程计算2的4次方。</p><p>mov ax,2H</p><p>add ax,ax <code>2H+2H=4H</code></p><p>add ax,ax <code>4H+4H=8H</code></p><p>add ax,ax <code>8H+8H=10H</code></p><h2 id="检测点-2-2" tabindex="-1"><a class="header-anchor" href="#检测点-2-2"><span>检测点 2.2</span></a></h2><p>（1）给定段地址0001H，仅通过变化偏移地址寻址，CPU的寻址范围为 <u>00010H 到 1000FH</u>。</p><p><code>基础地址 0001H*10=00010H</code></p><p><code>最小 00010H+0000H=00010H</code></p><p><code>最大 00010H+FFFFH=1000FH</code></p><p>（2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元，则SA应满足的条件是：<u>最小为1001H ，最大为2000H。</u></p><p><code>当最小为20000H时：</code></p><p><code>x*10+0000H=20000H</code></p><p><code>x=2000H</code></p><p><code>当最大为20000H时：</code></p><p><code>x*10+FFFFH=20000H</code></p><p><code>x=1000H 余1，所以想要寻到20000H,x需要加一为1001H</code></p><h2 id="检测点-2-3" tabindex="-1"><a class="header-anchor" href="#检测点-2-3"><span>检测点 2.3</span></a></h2><p>下面三条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>mov ax,bx</span></span>
<span class="line"><span>sub ax,ax</span></span>
<span class="line"><span>jmp ax</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答：4次修改IP，每条指令放入指令缓冲器后修改的IP还有jmp ax执行完后修改的IP，最后IP中的值是0。</p><p><code>每条指令在执行前都会改变IP，jmp ax指令会把IP修改为ax的值</code></p><h1 id="实验1-查看cpu和内存-用机器指令和汇编指令编程" tabindex="-1"><a class="header-anchor" href="#实验1-查看cpu和内存-用机器指令和汇编指令编程"><span>实验1 查看CPU和内存，用机器指令和汇编指令编程</span></a></h1><ul><li>查看、修改CPU中寄存器的内容：R命令</li><li>查看内存中的内容：D命令</li><li>修改内存中的内容：E命令（可以写入数据、指令，在内存中，它们实际上没有区别）</li><li>将内存中的内容解释为机器指令和对应的汇编指令：U命令</li><li>执行CS:IP指向的内存单元处的指令：T命令</li><li>以汇编指令的形式向内存中写入指令：A命令</li></ul><h1 id="第三章-寄存器-内存访问" tabindex="-1"><a class="header-anchor" href="#第三章-寄存器-内存访问"><span>第三章 寄存器（内存访问）</span></a></h1><h2 id="检测点-3-1" tabindex="-1"><a class="header-anchor" href="#检测点-3-1"><span>检测点 3.1</span></a></h2><p>（1）在Debug中，用“d 0:0 1f”查看内存，结果如下。</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210305100054191"></p><p>在下面的程序执行前，AX=0，BX=0，写出每条汇编指令执行完后相关寄存器中的值。（提示：注意ds的位置）</p><p>mov ax,1 <code>ax=0001</code></p><p>mov ds,ax <code>ax=0001,ds=0001</code></p><p>mov ax,[0000] <code>ax=2662,ds=0001</code> AX=<u>2662</u>H</p><p>mov bx,[0001] <code>ax=2662,ds=0001,bx=E626</code> BX=<u>E626</u>H</p><p>mov ax,bx <code>ax=E626,ds=0001,bx=E626</code> AX=<u>E626</u>H</p><p>mov ax,[0000] <code>ax=2662,ds=0001,bx=E626</code> AX=<u>2662H</u></p><p>mov bx,[0002] <code>ax=2662,ds=0001,bx=D6E6</code> BX=<u>D6E6H</u></p><p>add ax,bx <code>ax=FD48,ds=0001,bx=D6E6</code> AX=<u>FD48H</u></p><p>add ax,[0004] <code>ax=2C14,ds=0001,bx=D6E6</code> AX=<u>2C14H</u></p><p>mov ax,0 <code>ax=0000,ds=0001,bx=D6E6</code> AX=<u>0000H</u></p><p>mov al,[0002] <code>ax=00E6,ds=0001,bx=D6E6</code> AX=<u>00E6H</u></p><p>mov bx,0 <code>ax=00E6,ds=0001,bx=0000</code> BX=<u>0000H</u></p><p>mov bl,[000C] <code>ax=00E6,ds=0001,bx=0026</code> BX=<u>0026H</u></p><p>add al,bl <code>ax=00E6,ds=0001,bx=0000</code> AX=<u>000CH</u></p><p>（2）内存中的情况如图3.6所示。</p><p>各寄存器的初始值：CS=2000H,IP=0,DS=1000H,AX=0,BX=0;</p><ul><li>写出CPU执行的指令序列（用汇编指令写出）。</li><li>写出CPU执行每条指令后，CS、IP和相关寄存器中的数值。</li><li>再次体会：数据和程序有区别吗？如何确定内存中的信息哪些是数据，那些是程序？</li></ul><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210305132611767"></p><p>mov ax,6622H <code>CS=2000H,IP=0003H,DS=1000H,AX=6622H,BX=0</code></p><p>jmp 0ff0:0100 <code>CS=0ff0H,IP=0100H,DS=1000H,AX=6622H,BX=0</code></p><p>mov ax,2000H <code>CS=0ff0H,IP=0103H,DS=1000H,AX=2000H,BX=0</code></p><p>mov ds,ax <code>CS=0ff0H,IP=0105H,DS=2000H,AX=2000H,BX=0</code></p><p>mov ax,[0008] <code>CS=0ff0H,IP=0108H,DS=2000H,AX=C389H,BX=0</code></p><p>mov ax,[0002] <code>CS=0ff0H,IP=010BH,DS=2000H,AX=EA66H,BX=0</code></p><p>数据和程序在内存中没有区别，当CPU执行的时候用CS:IP在内存中取到的就是程序，当执行程序用到内存中的地址时，用DS:IP在内存中取到的就是数据。</p><h2 id="检测点-3-2" tabindex="-1"><a class="header-anchor" href="#检测点-3-2"><span>检测点 3.2</span></a></h2><p>（1）补全下面的程序，使其可以将10000H～1000FH中的8个字，逆序复制到20000H～2000FH中。逆序复制的含义如图3.7所示（图中内存里的数据均为假设）。</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210305230336679"></p><p>mov ax,1000H</p><p>mov ds,ax</p><p><u>mov ax,2000H</u> <code>栈段是复制的区域</code></p><p><u>mov ss,ax</u> <code>将SS指向20000H</code></p><p><u>mov sp,10H</u> <code>因为栈段的数据是空的，所以sp指向的栈顶是最高位+1</code></p><p>push [0]</p><p>push [2]</p><p>push [4]</p><p>push [6]</p><p>push [8]</p><p>push [A]</p><p>push [C]</p><p>push [E]</p><p>（2）补全下面的程序，使其可以将10000H～1000FH中的8个字，逆序复制到20000H～2000FH中。</p><p>mov ax,2000H</p><p>mov ds,ax</p><p><u>mov ax,1000H</u> <code>栈段是被复制的区域</code></p><p><u>mov ss,ax</u> <code>将ss指向10000H</code></p><p><u>mov sp,0</u> <code>因为栈段的数据是满的，所以sp指向的栈顶是最低位0</code></p><p>pop [E]</p><p>pop [C]</p><p>pop [A]</p><p>pop [8]</p><p>pop [6]</p><p>pop [4]</p><p>pop [2]</p><p>pop [0]</p><h1 id="实验2-用机器指令和汇编指令编程" tabindex="-1"><a class="header-anchor" href="#实验2-用机器指令和汇编指令编程"><span>实验2 用机器指令和汇编指令编程</span></a></h1><h2 id="实验任务" tabindex="-1"><a class="header-anchor" href="#实验任务"><span>实验任务</span></a></h2><p>（1）使用Debug，将下面的程序写入内存，逐条执行，根据指令执行后的实际运行情况填空。</p><p>（附加图：显示以下程序用到的内存中相关信息）</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="05253779-5A99-4517-8A59-DB44AA285381"></p><p>mov ax,ffff <img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306160224180"></p><p>mov ds,ax<img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306160305281"></p><p>mov ax,2200<img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306160400866"></p><p>mov ss,ax<img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306160528666"></p><p>mov sp,0100</p><p>mov ax,[0] AX= <u>C0EA</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306160615324"></p><p>add ax,[2] AX= <u>C0FC</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306161526335"></p><p>mov bx,[4] BX= <u>30F0</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306161621437"></p><p>add bx,[6] BX= <u>6021</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306161711038"></p><p>push ax SP= <u>00FE</u>;修改的内存单元地址是 <u>220FEH</u>,内容为 <u>C0FC</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306161949119"><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306162228865"></p><p>push bx SP= <u>00FC</u>;修改的内存单元地址是 <u>220FCH</u>,内容为 <u>6021</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306162300505"><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306162345608"></p><p>pop ax SP= <u>00FE</u>;AX= <u>6021</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306162926578"><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306162959954"></p><p>pop bx SP= <u>0100</u>;BX= <u>C0FC</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306163050044"><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306163116063"></p><p>push [4] SP= <u>00FE</u>;修改的内存单元地址是 <u>220FEH</u>,内容为 <u>30F0</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306163144672"><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306163209442"></p><p>push [6] SP= <u>00FC</u>;修改的内存单元地址是 <u>220FCH</u>,内容为 <u>2F31</u><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306163235432"><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210306163258009"></p><p>（2）仔细观察图3.19中的实验过程，然后分析：为什么2000:0～2000:f中的内容会发生变化？</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="20210306165106"></p><p>可能要再做些实验才能发现其中的规律。如果你在这里就正确回答了这个问题，那么要恭喜你，因为你有很好的悟性。大多数学习者对这个问题还是比较迷惑的，不过不要紧，因为随着课程的进行，这个问题的答案将逐渐变得显而易见。</p><h1 id="第四章-第一个程序" tabindex="-1"><a class="header-anchor" href="#第四章-第一个程序"><span>第四章 第一个程序</span></a></h1><h2 id="任务" tabindex="-1"><a class="header-anchor" href="#任务"><span>任务</span></a></h2><p>编程运算2^3。源程序应该怎样来写呢？</p><p>（1）我们要定义一个段，名称为abc。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>abc segment</span></span>
<span class="line"><span></span></span>
<span class="line"><span>……</span></span>
<span class="line"><span></span></span>
<span class="line"><span>abc ends</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）在这个段中写入汇编指令，来实现我们的任务。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>abc segment</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	mov ax,2</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>abc ends</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（3）然后，要指出程序在何处结束。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>abc segment</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	mov ax,2</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>abc ends</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）abc被当作代码段来用，所以，应该将abc和cs联系起来。（当然，对于这个程序，也不是非这样做不可。）</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:abc</span></span>
<span class="line"><span></span></span>
<span class="line"><span>abc segment</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	mov ax,2</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>abc ends</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（5）程序返回，在程序末尾添加返回的程序段。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:abc</span></span>
<span class="line"><span></span></span>
<span class="line"><span>abc segment</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	mov ax,2</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	add ax,ax</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,4c00H</span></span>
<span class="line"><span>	int 21H</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>abc ends</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在目前阶段，我们不必去理解 int 21H指令的含义，和为什么要在这条指令前面加上指令，mov ax,4c00H。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。</p><p>到目前为止，我们好像已经遇到了几个和结束相关的内容：段结束、程序结束、程序返回。表4.1展示了它们的区别。</p><p>![1EE9B1E7-1287-4800-8D98-73D212BE36E1](/Users/jiyuan/Library/Application Support/typora-user-images/1EE9B1E7-1287-4800-8D98-73D212BE36E1.png)</p><p>这里需要讲解一下在DOS系统中.EXE文件中的程序的加载过程。图4.20针对我们的问题，简要地展示了这个过程。</p><p>![CBE8F0B4-A20D-41E9-99EC-5222645E6751](/Users/jiyuan/Library/Application Support/typora-user-images/CBE8F0B4-A20D-41E9-99EC-5222645E6751.png)</p><h1 id="实验3-编程、编译、连接、跟踪" tabindex="-1"><a class="header-anchor" href="#实验3-编程、编译、连接、跟踪"><span>实验3 编程、编译、连接、跟踪</span></a></h1><p>（1）将下面的程序保存为t1.asm文件，将其生成可执行文件t1.exe。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:codesg</span></span>
<span class="line"><span></span></span>
<span class="line"><span>codesg segment</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,2000H</span></span>
<span class="line"><span>	mov ss,ax</span></span>
<span class="line"><span>	mov sp,0</span></span>
<span class="line"><span>	add sp,10</span></span>
<span class="line"><span>	pop ax</span></span>
<span class="line"><span>	pop bx</span></span>
<span class="line"><span>	push ax</span></span>
<span class="line"><span>	push bx</span></span>
<span class="line"><span>	pop ax</span></span>
<span class="line"><span>	pop bx</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,4c00H</span></span>
<span class="line"><span>	int 21H</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>codesg ends</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.pngg" alt="image-20210307211637387"></p><p>（2）用Debug跟踪t1.exe的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容。</p><p>mov ax,2000H</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307215922386"></p><p>mov ss,ax</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307215948555"></p><p>add sp,10H</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220020207"></p><p>pop ax</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220053175"></p><p>pop bx</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220510604"></p><p>push ax</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220544561"></p><p>push bx</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220620064"></p><p>pop ax</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220651751"></p><p>pop bx</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220732161"></p><p>mov ax,4c00H</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307220821511"></p><p>（3）PSP的头两个字节是CD20，用Debug加载t1.exe，查看PSP的内容。</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png" alt="image-20210307221400842"></p><p><code>CS=076A，指向的是程序的开头，PSP的段地址要-16，也就是提前了256个字节</code></p><h1 id="第五章-bx-和loop指令" tabindex="-1"><a class="header-anchor" href="#第五章-bx-和loop指令"><span>第五章 [BX]和loop指令</span></a></h1><p>要完整地描述一个内存单元，需要两种信息：（1）内存单元的地址（2）内存单元的长度（类型）。</p><p>debug中，p指令可直接跳过循环，或者使用g 0016直接执行到程序的CS:0016处。</p><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>将内存ffff:0<sub>ffff:b单元中的数据复制到0:200</sub>0:20b单元中。</p><p>思路：</p><p>（1）0:200～0:20b单元等同于0020:0～0020:b单元，它们描述的是同一段内存空间。</p><p>（2）复制的过程应用循环实现，简要描述如下。</p><p>初始化：</p><p>x=0</p><p>循环12次：</p><p>将ffff:X单元中的数据送入0020:X（需要用一个寄存器中转）</p><p>x=x+1</p><p>（3）再循环中，源始单元ffff:X和目标单元0020:X的偏移地址X是变量。我们用bx来存放。</p><p>（4）将0:200～0:20b用0020:0～0020:b描述，就是为了使目标的偏移地址和源始单元的偏移地址从同一数值0开始。</p><p>程序如下：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code</span></span>
<span class="line"><span></span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,0ffffh</span></span>
<span class="line"><span>	mov ds,ax</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,0020h</span></span>
<span class="line"><span>	mov es,ax</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov bx,0</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov cx,12</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>s:mov dl,[bx]</span></span>
<span class="line"><span>	mov es:[bx],dl</span></span>
<span class="line"><span>	inc bx</span></span>
<span class="line"><span>	loop s</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,4c00h</span></span>
<span class="line"><span>	int 21h</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序理解：</p><p>首先给ds赋值ffffh，es赋值0020h。</p><p>bx赋值0，此时ds:bx指向ffff:0，es:bx指向0020:0。</p><p>设置循环次数cx=12。</p><p>进入循环体：</p><p>首先把ds:bx的值赋给dl，再把dl赋给es:bx。</p><p>bx=bx+1。</p><p>cx-1，cx不等于0前持续执行循环。</p><p>程序结束。</p><h1 id="实验4-bx-和loop的使用" tabindex="-1"><a class="header-anchor" href="#实验4-bx-和loop的使用"><span>实验4 [bx]和loop的使用</span></a></h1><p>（1）编程，向内存0:200～0:23F依次传送数据0～63（3FH），程序只能使用9条指令，9条指令包括“mov ax,4c00h”和“int 21h”。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code</span></span>
<span class="line"><span></span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,0020h</span></span>
<span class="line"><span>	mov ds,ax</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	mov bx,0</span></span>
<span class="line"><span>	mov cx,64</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>s:mov [bx],bx</span></span>
<span class="line"><span>	inc bx</span></span>
<span class="line"><span>	loop s</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>	mov ax,4c00h</span></span>
<span class="line"><span>	int 21h</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span></span></span>
<span class="line"><span>end</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>程序理解：首先将ds指向0020即0:200，然后初始化参数bx=0，因为写入的数据和内存的偏移地址一致，所以bx可以两用。设置循环次数64次，执行循环体，把bx的值写入ds:bx，然后bx+1。</code></p><p>（2）下面的程序的功能是将“mov ax,4c00h”之前的指令复制到内存0:200处，补全程序。上机调试，跟踪运行结果。</p><p>Assume cs:code</p><p>code segment</p><p>​ mov ax, <u>cs</u> <code>ds指向程序的第一句</code></p><p>​ mov ds,ax</p><p>​ mov ax,0020h</p><p>​ mov es,ax</p><p>​ mov bx,0</p><p>​ mov cx,<u>16h</u> <code>mov ax,4c00h之前的程序长度是16h</code></p><p>s:mov al,[bx]</p><p>​ mov es:[bx],al</p><p>​ inc bx</p><p>​ loop s</p><p>​ mov ax,4c00h</p><p>​ int 21h</p><p>code ends</p><p>end</p><p>提示：</p><ol><li>复制的是什么？从哪里到哪里？</li><li>复制的是什么？有多少个字节？你如何知道要复制的字节数量？</li></ol><h1 id="第六章-包含多个段的程序" tabindex="-1"><a class="header-anchor" href="#第六章-包含多个段的程序"><span>第六章 包含多个段的程序</span></a></h1><p>dw即“define word”，含义是定义字型数据。占两个单位的内存空间。</p><p>db含义是定义字节型数据。占一个单位的内存空间。</p><p>end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序的第一条指令前面加上一个标号start，在end后面加上标号start。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code</span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>	数据</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>start:</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>	代码</span></span>
<span class="line"><span>	...</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span>end start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="检测点-6-1" tabindex="-1"><a class="header-anchor" href="#检测点-6-1"><span>检测点 6.1</span></a></h2><p>（1）下面的程序实现依次用内存0:0~0:15单元中的内容改写程序中的数据，完成程序：</p><p>assume cs:codesg</p><p>codesg segment</p><p>​ dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</p><p>start: mov ax,0</p><p>​ mov ds,ax</p><p>​ mov bx,0</p><p>​ mov cx,8</p><p>​ s: mov ax,[bx]</p><p>​ <u>mov cs:[bx],ax</u> <code>将指定内存中的数据先放到ax，再赋值给当前程序的数据中</code></p><p>​ add bx,2</p><p>​ loop s</p><p>​ mov ax,4c00h</p><p>​ int 21h</p><p>codes ends</p><p>end start</p><p>（2）下面的程序实现依次用内存0:0～0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置在程序内。完成程序：</p><p>assume cs:codesg</p><p>codesg segment</p><p>​ dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</p><p>​ dw 0,0,0,0,0,0,0,0,0,0</p><p>start:mov ax, <u>cs</u> <code>栈顶指向程序的开头</code></p><p>​ mov ss,ax</p><p>​ mov sp, <u>24h</u> <code>数据段一共18个字单元，占36个字节</code></p><p>​ mov ax,0</p><p>​ mov ds,ax</p><p>​ mov bx,0</p><p>​ mov cx,8</p><p>​ s: push [bx]</p><p>​ <u>pop cs:[bx]</u> <code>将栈中的数据取出到对应的内存位置中</code></p><p>​ add bx,2</p><p>​ loop s</p><p>​ mov ax,4c00h</p><p>​ int 21h</p><p>codesg ends</p><p>end start</p><h1 id="实验5-编写、调试具有多个段的程序" tabindex="-1"><a class="header-anchor" href="#实验5-编写、调试具有多个段的程序"><span>实验5 编写、调试具有多个段的程序</span></a></h1><p>（1）将下面的程序编译、连接，用Debug加载、跟踪，然后回答问题。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code,ds:data,ss:stack</span></span>
<span class="line"><span>data segment</span></span>
<span class="line"><span>	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span></span>
<span class="line"><span>data ends</span></span>
<span class="line"><span>stack segment</span></span>
<span class="line"><span>	dw 0,0,0,0,0,0,0,0</span></span>
<span class="line"><span>stack ends</span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>start:mov ax,stack</span></span>
<span class="line"><span>			mov ss,ax</span></span>
<span class="line"><span>			mov sp,16</span></span>
<span class="line"><span>			mov ax,data</span></span>
<span class="line"><span>			mov ds,ax</span></span>
<span class="line"><span>			push ds:[0]</span></span>
<span class="line"><span>			push ds:[2]</span></span>
<span class="line"><span>			pop ds:[2]</span></span>
<span class="line"><span>			pop ds:[0]</span></span>
<span class="line"><span>			mov ax,4c00h</span></span>
<span class="line"><span>			int 21h</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span>end start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>CPU执行程序，程序返回前，data段中的数据为多少？</li><li>CPU执行程序，程序返回前，cs=、ss=、ds=。</li><li>设程序加载后，code段的段地址为X，则data段的段地址为，stack段的段地址为。</li></ol><p>data段中的数据：不变<img src="https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png?t=0313161626401.png" alt="image-20210313161626401"></p><p>cs=076ch,ss=076bh,ds=076ah</p><p>code段：X</p><p>data段：X-2</p><p>stack段：X-1</p><p>（2）将下面的程序编译、连接，用Debug加载、跟踪，然后回答问题。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code,ds:data,ss:stack</span></span>
<span class="line"><span>data segment</span></span>
<span class="line"><span>	dw 0123h,0456h</span></span>
<span class="line"><span>data ends</span></span>
<span class="line"><span>stack segment</span></span>
<span class="line"><span>	dw 0,0</span></span>
<span class="line"><span>stack ends</span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>start:mov ax,stack</span></span>
<span class="line"><span>			mov ss,ax</span></span>
<span class="line"><span>			mov sp,16</span></span>
<span class="line"><span>			mov ax,data</span></span>
<span class="line"><span>			mov ds,ax</span></span>
<span class="line"><span>			push ds:[0]</span></span>
<span class="line"><span>			push ds:[2]</span></span>
<span class="line"><span>			pop ds:[2]</span></span>
<span class="line"><span>			pop ds:[0]</span></span>
<span class="line"><span>			mov ax,4c00h</span></span>
<span class="line"><span>			int 21h</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span>end start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><p>CPU执行程序，程序返回前，data段中的数据为多少？</p></li><li><p>CPU执行程序，程序返回前，cs=、ss=、ds=。</p></li><li><p>设程序加载后，code段的段地址为X，则data段的段地址为，stack段的段地址为。</p></li><li><p>对于如下定义的段：</p><p>name segment</p><p>​ ...</p><p>name ends</p><p>如果段中的数据占N个字节，则程序加载后，该段实际占有空间为。</p></li></ol><p>data中的数据：23 01 56 04 不变</p><p>cs=076ch，ss=076bh，ds=076ah</p><p>code段：X</p><p>data段：X-2</p><p>stack段：X-1</p><p>实际占有空间为(N/16+1)*16 <code>/为整数除法</code></p><p><code>分配的空间是16的倍数且大于等于段中数据的字节数，假设xx中有17字节的数据，则会为其分配32字节的空间</code></p><p><code>N/16只取整数部分或(N+15)/16，对16取整，在8086CPU架构上，段是以paragraph（16-byte）对齐的。程序默认以16字节为边界对齐，所以不足16字节的部分数据也要填够16字节。“对齐”是alignment，这种填充叫做padding。16字节成一小段，成为节。</code></p><p>（3）将下面的程序编译、连接，用Debug加载、跟踪，然后回答问题。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code,ds:data,ss:stack</span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>start:mov ax,stack</span></span>
<span class="line"><span>			mov ss,ax</span></span>
<span class="line"><span>			mov sp,16</span></span>
<span class="line"><span>			mov ax,data</span></span>
<span class="line"><span>			mov ds,ax</span></span>
<span class="line"><span>			push ds:[0]</span></span>
<span class="line"><span>			push ds:[2]</span></span>
<span class="line"><span>			pop ds:[2]</span></span>
<span class="line"><span>			pop ds:[0]</span></span>
<span class="line"><span>			mov ax,4c00h</span></span>
<span class="line"><span>			int 21h</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span>data segment</span></span>
<span class="line"><span>	dw 0123h,0456h</span></span>
<span class="line"><span>data ends</span></span>
<span class="line"><span>stack segment</span></span>
<span class="line"><span>	dw 0,0</span></span>
<span class="line"><span>stack ends</span></span>
<span class="line"><span>end start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>CPU执行程序，程序返回前，data段中的数据为多少？</li><li>CPU执行程序，程序返回前，cs=、ss=、ds=。</li><li>设程序加载后，code段的段地址为X，则data段的段地址为，stack段的段地址为。</li></ol><p>data中的数据：23 01 56 04 不变</p><p>cs=076ah，ss=076eh，ds=076dh</p><p>code段：X</p><p>data段：X+3</p><p>stack段：X+4</p><p>（4）如果将（1）（2）（3）题中的最后一条伪指令“end start”改为“end”（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。</p><p>都能运行，但3的程序可能正确执行。</p><p>如果不指明程序的入口，那么从加载入内存的第一个单元开始执行，尽管前两题的代码是数据段放在最前面，但也可以被翻译为汇编指令（毕竟最终都是机器码），但不是我们真正想要执行的，而第三题恰好程序段放在最先，CPU在执行真正的机器码时，遇到中断指令后返回，如果程序段不在最前面，必须指定程序的入口。</p><p>（5）程序如下，编写code段中的代码，将a段和b段中的数据依次相加，将结果存到c段中。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code</span></span>
<span class="line"><span>a segment</span></span>
<span class="line"><span>	db 1,2,3,4,5,6,7,8</span></span>
<span class="line"><span>a ends</span></span>
<span class="line"><span>b segment</span></span>
<span class="line"><span>	db 1,2,3,4,5,6,7,8</span></span>
<span class="line"><span>b ends</span></span>
<span class="line"><span>c segment</span></span>
<span class="line"><span>	db 0,0,0,0,0,0,0,0</span></span>
<span class="line"><span>c ends</span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>start:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>		mov ax,a</span></span>
<span class="line"><span>    mov ds,ax  ;ds指向a段</span></span>
<span class="line"><span>    mov ax,b</span></span>
<span class="line"><span>    mov es,ax  ;es指向b段</span></span>
<span class="line"><span>    mov bx,0</span></span>
<span class="line"><span>    mov cx,8  ;循环8次</span></span>
<span class="line"><span>  s:mov dl,[bx]  ;将ds:[bx]内存单元按字节送入dl</span></span>
<span class="line"><span>    add dl,es:[bx]  ;将ds:[bx]与es:[bx]内存单元值相加</span></span>
<span class="line"><span>    push ds  ;保护ds值，下面还会用到</span></span>
<span class="line"><span>    mov ax,c</span></span>
<span class="line"><span>    mov ds,ax  ;将ds指向c段</span></span>
<span class="line"><span>    mov [bx],dl  ;将dl（a和b相对应内存单元内容之和）写入c中</span></span>
<span class="line"><span>    pop ds  ;将ds恢复</span></span>
<span class="line"><span>    inc bx  ;bx+1</span></span>
<span class="line"><span>    loop s</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    mov ax,4c00h</span></span>
<span class="line"><span>    int 21h</span></span>
<span class="line"><span>		</span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span>end start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（6）程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>assume cs:code</span></span>
<span class="line"><span>a segment</span></span>
<span class="line"><span>	dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh</span></span>
<span class="line"><span>a ends</span></span>
<span class="line"><span>b segment</span></span>
<span class="line"><span>	dw 0,0,0,0,0,0,0,0</span></span>
<span class="line"><span>b ends</span></span>
<span class="line"><span>code segment</span></span>
<span class="line"><span>start:</span></span>
<span class="line"><span></span></span>
<span class="line"><span>		mov ax,a</span></span>
<span class="line"><span>		mov ds,ax  ;将ds指向a段</span></span>
<span class="line"><span>		mov ax,b</span></span>
<span class="line"><span>		mov ss,ax  ;将栈顶指向b段</span></span>
<span class="line"><span>		mov sp,10h  ;将sp指向栈底10h</span></span>
<span class="line"><span>		mov bx,0</span></span>
<span class="line"><span>		mov cx,8</span></span>
<span class="line"><span>  s:push [bx]  ;a段和b段都是字型数据，所以直接push</span></span>
<span class="line"><span>  	add bx,2  ;每个字型数据宽度为2，所以每次加2</span></span>
<span class="line"><span>  	loop s</span></span>
<span class="line"><span>  	</span></span>
<span class="line"><span>  	mov ax,4c00h</span></span>
<span class="line"><span>  	int 21h</span></span>
<span class="line"><span></span></span>
<span class="line"><span>code ends</span></span>
<span class="line"><span>end start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="第七章-更灵活的定位内存地址的方法" tabindex="-1"><a class="header-anchor" href="#第七章-更灵活的定位内存地址的方法"><span>第七章 更灵活的定位内存地址的方法</span></a></h1><p>and指令：逻辑与指令，按位进行运算。</p><p>or指令：逻辑或指令，按位进行或运算。</p>`,314)]))}const t=a(i,[["render",l],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/article/htumg7nv/","title":"汇编语言第三版笔记","lang":"zh-CN","frontmatter":{"title":"汇编语言第三版笔记","tags":["笔记","学习","待续"],"createTime":"2021/10/11","permalink":"/article/htumg7nv/","description":"检测点 1.1 （1）1个CPU的寻址能力为8KB，那么它的地址总线的宽度是 13。 一个内存单元是1B，一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。8KB=8*2^10B=2^3*2^10B=2^13B,N=13 （2）1KB的存储器有 1024 个存储单元。存储单元的编号从 0 到 1...","head":[["meta",{"property":"og:url","content":"https://jyqwq.github.io/rainbow/article/htumg7nv/"}],["meta",{"property":"og:site_name","content":"纸上的彩虹"}],["meta",{"property":"og:title","content":"汇编语言第三版笔记"}],["meta",{"property":"og:description","content":"检测点 1.1 （1）1个CPU的寻址能力为8KB，那么它的地址总线的宽度是 13。 一个内存单元是1B，一个CPU有N根地址线，则可以说这个CPU的地址总线宽度为N。这样的CPU最多可以寻找2的N次方个内存单元。8KB=8*2^10B=2^3*2^10B=2^13B,N=13 （2）1KB的存储器有 1024 个存储单元。存储单元的编号从 0 到 1..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-02T09:13:05.000Z"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"学习"}],["meta",{"property":"article:tag","content":"待续"}],["meta",{"property":"article:modified_time","content":"2024-12-02T09:13:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"汇编语言第三版笔记\\",\\"image\\":[\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://jyqwq.github.io/rainbow/Users/jiyuan/Library/Application Support/typora-user-images/1EE9B1E7-1287-4800-8D98-73D212BE36E1.png\\",\\"https://jyqwq.github.io/rainbow/Users/jiyuan/Library/Application Support/typora-user-images/CBE8F0B4-A20D-41E9-99EC-5222645E6751.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.pngg\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/image-fail.png?t=0313161626401.png\\"],\\"dateModified\\":\\"2024-12-02T09:13:05.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":18.07,"words":5422},"git":{"updatedTime":1733130785000,"contributors":[{"name":"yuan.ji","email":"yuan.ji@ly.com","commits":2,"avatar":"https://avatars.githubusercontent.com/yuan.ji?v=4","url":"https://github.com/yuan.ji"}]},"autoDesc":true,"filePathRelative":"日常学习/汇编语言第三版笔记.md","categoryList":[{"id":"9a91b4","sort":10003,"name":"日常学习"}],"bulletin":false}');export{t as comp,m as data};
