import{_ as a,c as s,f as i,o as t}from"./app-_cZTuvS3.js";const n={};function d(l,e){return t(),s("div",null,e[0]||(e[0]=[i(`<h2 id="docker简介" tabindex="-1"><a class="header-anchor" href="#docker简介"><span>Docker简介</span></a></h2><p>容器化技术：一个不完整的操作系统。</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/blog-1.png" alt="image-20210504174158226.png"></p><p><strong>Docker为什么比虚拟机快？</strong></p><ol><li>Docker有着比虚拟机更少的抽象层</li><li>Docker利用的是宿主机的内核</li></ol><p>所以说，新建容器时，docker不需要像虚拟机一样重新加载一个操作系统，避免引导。</p><p>VM是硬件虚拟化，Docker是OS虚拟化。</p><p>VM会有5-20%的性能损耗，Docker是物理机性能。</p><h2 id="常用指令" tabindex="-1"><a class="header-anchor" href="#常用指令"><span>常用指令</span></a></h2><p>docker version</p><p>docker info</p><p>docker --help</p><p>docker pull [] <code>下载镜像</code></p><p>docker search [] <code>搜索镜像</code></p><p>docker rmi [] <code>删除镜像</code></p><p>docker rmi -f $(docker images -aq) <code>删除所有镜像</code></p><p>docker images <code>查看镜像</code></p><h2 id="新建容器并启动" tabindex="-1"><a class="header-anchor" href="#新建容器并启动"><span>新建容器并启动</span></a></h2><p>docker run [可选参数] [image]</p><p>--name=&quot;name01&quot; <code>容器名字</code></p><p>-d <code>后台方式运行</code></p><p>-it <code>使用交互式运行，进入容器查看内容</code></p><p>-p <code>指定容器端口，-p 8080:8080（主机端口:容器端口）</code></p><p>-P <code>随机端口</code></p><p>利用 <code>docker run</code>来创建容器时，Docker在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定镜像，不存在就从共有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h2 id="列出所有运行的容器" tabindex="-1"><a class="header-anchor" href="#列出所有运行的容器"><span>列出所有运行的容器</span></a></h2><p>docker ps [-a] <code>带出历史运行过的，[-n=?]最近运行的n个</code></p><p>-q <code>只显示容器编号</code></p><h2 id="退出容器" tabindex="-1"><a class="header-anchor" href="#退出容器"><span>退出容器</span></a></h2><p>exit <code>退出容器</code></p><p>ctrl+P+Q <code>退出不停止</code></p><h2 id="删除容器" tabindex="-1"><a class="header-anchor" href="#删除容器"><span>删除容器</span></a></h2><p>docker rm 容器id <code>删除容器</code></p><p>docker rm -f $(docker ps -aq) <code>删除所有容器</code></p><h2 id="启动重启和停止关闭" tabindex="-1"><a class="header-anchor" href="#启动重启和停止关闭"><span>启动重启和停止关闭</span></a></h2><p>docker start 容器id</p><p>docker restart 容器id</p><p>docker stop 容器id</p><p>docker kill 容器id</p><p><strong>docker容器使用后台运行时（docker run -d [镜像名]），如果没有前台进程，就会立即停止。例如nginx，容器启动后，发现自己没有提供服务就会立即停止，就是没有程序了。</strong></p><h2 id="查看日志" tabindex="-1"><a class="header-anchor" href="#查看日志"><span>查看日志</span></a></h2><p>docker logs [-tf] <code>显示全部带时间戳</code></p><p>--tail + num <code>查看日志数量</code></p><h2 id="查看容器中进程信息" tabindex="-1"><a class="header-anchor" href="#查看容器中进程信息"><span>查看容器中进程信息</span></a></h2><p>docker top 容器id</p><h2 id="查看镜像元数据" tabindex="-1"><a class="header-anchor" href="#查看镜像元数据"><span>查看镜像元数据</span></a></h2><p>docker inspect 容器id</p><h2 id="进入当前正在运行的容器" tabindex="-1"><a class="header-anchor" href="#进入当前正在运行的容器"><span>进入当前正在运行的容器</span></a></h2><p>我们通常容器都使用后台运行，需要进入容器，修改一些配置。</p><p>docker exec -it 容器id bashshell</p><p>docker attach 容器id</p><p>exec <code>进入容器后开启新的终端，可进行操作</code></p><p>attach <code>进入容器正在执行的终端，不开启新进程</code></p><h2 id="从容器内拷贝文件到主机" tabindex="-1"><a class="header-anchor" href="#从容器内拷贝文件到主机"><span>从容器内拷贝文件到主机</span></a></h2><p>docker cp 容器id:容器内路径 目的的主机路径</p><h2 id="查看cpu状态" tabindex="-1"><a class="header-anchor" href="#查看cpu状态"><span>查看CPU状态</span></a></h2><p>docker stats</p><h2 id="可视化-protainer" tabindex="-1"><a class="header-anchor" href="#可视化-protainer"><span>可视化（protainer）</span></a></h2><p>Docker图形化界面</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker run -d -p 8088:9000  --restart=always -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>访问方式：http://IP:8088</p><h2 id="commit镜像" tabindex="-1"><a class="header-anchor" href="#commit镜像"><span>commit镜像</span></a></h2><p>docker commit <code>提交镜像成为一个新的副本</code></p><p>docker commit -m=&quot;提交内容&quot; -a=&quot;作者名&quot; 容器id 目标镜像名:[TAG]</p><h2 id="容器数据卷" tabindex="-1"><a class="header-anchor" href="#容器数据卷"><span>容器数据卷</span></a></h2><p>容器间可以有一个数据共享的数据。Docker容器中产生的数据同步到本地。</p><p>数据卷是一个可供一个或多个容器使用的特殊目录，它绕过UFS，可以提供很多有用的特性：</p><ul><li>数据卷可以在容器之间共享和重用</li><li>对数据卷的修改会立马生效</li><li>对数据卷的更新，不会影响到镜像</li><li>卷会一直存在，直到没有容器使用</li></ul><p>总结：容器持久化和同步操作，容器间也可以共享数据。</p><p>使用：docker run -it -v 主机目录:容器目录 bashshell<code>主机目录必须是绝对路径，如果不存在docker自动创建</code></p><p>docker挂载数据卷的默认权限是读写，用户也可以通过<code>:ro</code>指定为只读</p><p>举例：MySql数据持久化</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>docker run 后台运行 端口映射 卷挂载 环境配置 容器命名 镜像名</p><h2 id="容器和镜像的区别" tabindex="-1"><a class="header-anchor" href="#容器和镜像的区别"><span>容器和镜像的区别</span></a></h2><p>镜像是只读的不能被保存或修改，一个镜像可以构建在另一个镜像之上，这种层叠关系是多层的。</p><p>容器就是在所有的镜像层之上增加一个可写层。这个可写层有运行在CPU上的进程，而且有两个不同的状态：运行态和停止态。从运行态到停止态，我们对它所做的一切都会永久地写到容器的文件系统中，注意不是镜像中。可以用一个镜像启动多个容器，各个容器间相互隔离。</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/blog-2.png" alt="image-20210505172410099.png"></p><h2 id="具名挂载和匿名挂载" tabindex="-1"><a class="header-anchor" href="#具名挂载和匿名挂载"><span>具名挂载和匿名挂载</span></a></h2><ul><li>匿名挂载：docker run -d -P -v /etc/nginx</li><li>具名挂载：docker run -d -P -v name01:/etc/nginx</li></ul><h2 id="查看卷列表" tabindex="-1"><a class="header-anchor" href="#查看卷列表"><span>查看卷列表</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker volume ls</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="查看卷信息" tabindex="-1"><a class="header-anchor" href="#查看卷信息"><span>查看卷信息</span></a></h2><p>docker volume inspect 卷名</p><p>-v 容器内路径 <code>匿名挂载</code></p><p>-v 卷名:容器内路径 <code>具名挂载</code></p><p>-v 宿主机路径:容器内路径 <code>指定路径挂载</code></p><p>-v 容器内路径:ro(只读) rw(可读可写)</p><h2 id="数据卷容器" tabindex="-1"><a class="header-anchor" href="#数据卷容器"><span>数据卷容器</span></a></h2><p>数据卷容器，其实就是一个正常的容器，专门用来提供数据卷为其他容器挂载的。</p><p>首先，创建一个命名的数据卷容器dbdata：</p><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -d</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -v</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> /dbdata</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --name</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dbdata</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> training/postgres</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> echo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> Data-only</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> container</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>然后，在其他容器中使用<code>--volumes-from 容器名</code>来挂载dbdata容器中的数据卷</p><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -d</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --volumes-from</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dbdata</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --name</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> db1</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> training/postgres</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">docker</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> run</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> -d</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --volumes-from</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> dbdata</span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;"> --name</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> db2</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> training/postgres</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以使用多个<code>--volumes-from</code>参数来从多个容器挂载多个数据卷。也可以从其他已经挂载了数据卷的容器来挂载数据卷。</p><p>如果删除了挂载的容器(包括 dbdata、db1 和 db2)，数据卷并不会被自动删除。如果要删除一个数据 卷，必须在删除最后一个还挂载着它的容器时使用 <code>docker rm -v</code> 命令来指定同时删除关联的容器。 这可以让用户在容器之间升级和移动数据卷。</p><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile"><span>DockerFile</span></a></h2><p>用来构建docker镜像的构建文件，命令脚本。通过这个脚本可以生成镜像，镜像是一层层的，脚本是一个个的命令，每个命令都是一层。</p><p><strong>Docker构建步骤</strong></p><ol><li>编写一个dockerfile文件</li><li>docker build构建成一个镜像</li><li>docker run运行镜像</li><li>docker push发布镜像（DockerHub，阿里云……）</li></ol><h2 id="dockerfile指令" tabindex="-1"><a class="header-anchor" href="#dockerfile指令"><span>DockerFile指令</span></a></h2><table><thead><tr><th style="text-align:center;">指令</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center;">FROM</td><td>基础镜像，一切从这里开始</td></tr><tr><td style="text-align:center;">MAINTAINER</td><td>镜像是谁写的，姓名+邮箱</td></tr><tr><td style="text-align:center;">RUN</td><td>运行命令</td></tr><tr><td style="text-align:center;">ADD</td><td>添加内容，可解压tar包（不同于COPY的地方）</td></tr><tr><td style="text-align:center;">WORKDIR</td><td>镜像工作目录</td></tr><tr><td style="text-align:center;">VOLUME</td><td>挂载的目录</td></tr><tr><td style="text-align:center;">EXPOSE</td><td>指定暴露端口（同-P指令）</td></tr><tr><td style="text-align:center;">CMD</td><td>指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行，可被替代。</td></tr><tr><td style="text-align:center;">ENTRYPOINT</td><td>如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。ENTRYPOINT可追加命令。每个 Dockerfile 中只能有一个 ENTRYPOINT ，当指定多个时，只有最后一个起效。</td></tr><tr><td style="text-align:center;">ONBUILD</td><td>当构建一个被继承DockerFile这个时候就会运行ONBUILD指令。触发指令</td></tr><tr><td style="text-align:center;">COPY</td><td>类似ADD，将我们的文件拷贝到镜像中</td></tr><tr><td style="text-align:center;">ENV</td><td>构建时设置环境变量</td></tr></tbody></table><p><strong>DockerHub中99%的镜像都是FROM scratch</strong></p><h2 id="dockerfile例子" tabindex="-1"><a class="header-anchor" href="#dockerfile例子"><span>DockerFile例子</span></a></h2><p>创建一个自己的centos</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>FROM centos</span></span>
<span class="line"><span>MAINTAINER jy&lt;jy@test.com&gt;</span></span>
<span class="line"><span>ENV MYPATH /usr/local</span></span>
<span class="line"><span>WORKDIR $MYPATH</span></span>
<span class="line"><span>RUN yum -y install vim</span></span>
<span class="line"><span>RUN yum -y install net-tools</span></span>
<span class="line"><span>EXPOSE 80</span></span>
<span class="line"><span>CMD echo $MYPATH</span></span>
<span class="line"><span>CMD echo &quot;---end---&quot;</span></span>
<span class="line"><span>CMD /bin/bash</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="运行dockerfile文件" tabindex="-1"><a class="header-anchor" href="#运行dockerfile文件"><span>运行DockerFile文件</span></a></h2><p>docker build -f 文件路径 -t 镜像名:[TAG] . <code>最后要加一个.</code></p><p>docker history 镜像id <code>可以看镜像的构建过程</code></p><p><strong>编写dockerfile文件，官方命名Dockerfile，build就会自动找，不需要-f指定文件了</strong></p><p><strong>注意：一个镜像不能超过127层</strong></p><h2 id="cmd和entrypoint" tabindex="-1"><a class="header-anchor" href="#cmd和entrypoint"><span>CMD和ENTRYPOINT</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>CMD [&quot;ls&quot;,&quot;-a&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>run时执行 ls -a</p><p>当Dockerfile中有CMD命令时</p><p>docker run 镜像id ls -al</p><p>追加的命令会替换CMD语句，所以如果追加-l会出错，相当于CMD [&quot;-l&quot;]</p><p>但如果是</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>docker run 镜像id -l</p><p>就不会出错，会追加在ENTRYPOINT指令上</p><h2 id="发布自己的镜像" tabindex="-1"><a class="header-anchor" href="#发布自己的镜像"><span>发布自己的镜像</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker login -u xx -p xx</span></span>
<span class="line"><span>docker push 镜像id:[TAG]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>阿里云的镜像容器，可参考阿里云官网</p><h2 id="docker网络" tabindex="-1"><a class="header-anchor" href="#docker网络"><span>Docker网络</span></a></h2><p><strong>理解Docker0（使用ip addr查看网卡信息）</strong></p><p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理 解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p><p>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口(当数据包发送到一个接口时，另外 一个接口也可以收到相同的数据包)。这对接口一端在容器内，即 eth0 ;另一端在本地并被挂载到</p><p>docker0 网桥，名称以 veth 开头(例如 vethAQI2QT )。通过这种方式，主机可以跟容器通信，容器 之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/blog-3.png" alt="image-20210528225349265.png"></p><p>原理：</p><ol><li>我们每启动一个docker容器，docker就会给容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0。</li><li>桥接模式，使用的技术是veth-pair技术。</li><li>这个容器带来的网卡都是一一对应的。</li><li>veth-pair就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连。</li><li>正因为有这个特性，veth-pair充当一个桥梁，连接各种虚拟网络设备的。</li></ol><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/blog-4.png" alt="image-20210507205851773.png"></p><p>如图，tomcat01和tomcat02是公用的一个路由器，docker0所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用IP。</p><p>Docker中的所有网络接口都是虚拟的。虚拟的转发效率高！只要删除容器，对应的一对网桥就没了。</p><h2 id="容器访问外网" tabindex="-1"><a class="header-anchor" href="#容器访问外网"><span>容器访问外网</span></a></h2><p>容器要想访问外部网络，需要本地系统的转发支持。</p><p>在Linux 系统中，检查转发是否打开。</p><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> $sysctl</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> net.ipv4.ip_forward</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> net.ipv4.ip_forward</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果为 0，说明没有开启转发，则需要手动打开。</p><div class="language-shell line-numbers-mode" data-ext="shell" data-title="shell"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">$sysctl</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> -w net.ipv4.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">ip_forward</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果在启动 Docker 服务的时候设定 <code>--ip-forward=true </code>, Docker 就会自动设定系统的 ip_forward 参数 为 1。</p><h2 id="link" tabindex="-1"><a class="header-anchor" href="#link"><span>--link</span></a></h2><p><strong>不需要用ip直接用容器名（服务名）ping</strong></p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker exec -it tomcat02 ping tomcat01</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>上面的无法ping通！</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker run -d -P --name tomcat03 --link tomcat02 tomcatdocker exec -it tomcat03 ping tomcat02</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>此时就可以ping同通</p><p>原理：</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker exec -it tomcat03 cat /etc/hosts</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>总结：</p><p>--link就是在hosts配置中增加一个映射</p><h2 id="查看网络信息" tabindex="-1"><a class="header-anchor" href="#查看网络信息"><span>查看网络信息</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker network lsdocker network inspect 网络ID</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="网络模式" tabindex="-1"><a class="header-anchor" href="#网络模式"><span>网络模式</span></a></h2><p>bridge：桥接模式（默认）</p><p>none：不配置网络</p><p>host：和宿主机共享网络</p><p>container：容器网络连通（用得少，局限大）</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker run -d -P --name tomcat01 --net bridge tomcat</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>docker0特点：默认，域名不能访问，--link可以打通</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>解释：docker network create 桥接的网络模式 子网 网关 名称</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker run -d -P --name tomcat01 --net mynet tomcat</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>可以直接互相ping通</p><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker exec -it tomcat01 ping tomcat02</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="网络连通" tabindex="-1"><a class="header-anchor" href="#网络连通"><span>网络连通</span></a></h2><div class="language- line-numbers-mode" data-ext="" data-title=""><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>docker network connect mynet tomcat00</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不同网络下的容器也能互相连通，tomcat00是其他网络下的容器</p><h2 id="docker底层实现和网络实现" tabindex="-1"><a class="header-anchor" href="#docker底层实现和网络实现"><span>Docker底层实现和网络实现</span></a></h2><p>Docker 底层的核心技术包括 Linux 上的名字空间(Namespaces)、控制组(Control groups)、Union 文</p><p>件系统(Union file systems)和容器格式(Container format)。</p><p>Docker 的网络实现其实就是利用了 Linux 上的网络名字空间和虚拟网络设备(特别是 veth pair)。</p><h2 id="一张图总结docker的命令" tabindex="-1"><a class="header-anchor" href="#一张图总结docker的命令"><span>一张图总结Docker的命令</span></a></h2><p><img src="https://file.40017.cn/baoxian/health/health_public/images/blog/blog-5.png" alt="image-20210529113037532.png"></p>`,176)]))}const p=a(n,[["render",d],["__file","index.html.vue"]]),c=JSON.parse('{"path":"/article/wtw37qhs/","title":"Docker","lang":"zh-CN","frontmatter":{"title":"Docker","tags":["笔记","学习","docker"],"createTime":"2021/10/11","permalink":"/article/wtw37qhs/","description":"Docker简介 容器化技术：一个不完整的操作系统。 image-20210504174158226.png Docker为什么比虚拟机快？ Docker有着比虚拟机更少的抽象层 Docker利用的是宿主机的内核 所以说，新建容器时，docker不需要像虚拟机一样重新加载一个操作系统，避免引导。 VM是硬件虚拟化，Docker是OS虚拟化。 VM会有5...","head":[["meta",{"property":"og:url","content":"https://jyqwq.github.io/rainbow/article/wtw37qhs/"}],["meta",{"property":"og:site_name","content":"纸上的彩虹"}],["meta",{"property":"og:title","content":"Docker"}],["meta",{"property":"og:description","content":"Docker简介 容器化技术：一个不完整的操作系统。 image-20210504174158226.png Docker为什么比虚拟机快？ Docker有着比虚拟机更少的抽象层 Docker利用的是宿主机的内核 所以说，新建容器时，docker不需要像虚拟机一样重新加载一个操作系统，避免引导。 VM是硬件虚拟化，Docker是OS虚拟化。 VM会有5..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://file.40017.cn/baoxian/health/health_public/images/blog/blog-1.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-02T08:08:41.000Z"}],["meta",{"property":"article:tag","content":"笔记"}],["meta",{"property":"article:tag","content":"学习"}],["meta",{"property":"article:tag","content":"docker"}],["meta",{"property":"article:modified_time","content":"2024-12-02T08:08:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker\\",\\"image\\":[\\"https://file.40017.cn/baoxian/health/health_public/images/blog/blog-1.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/blog-2.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/blog-3.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/blog-4.png\\",\\"https://file.40017.cn/baoxian/health/health_public/images/blog/blog-5.png\\"],\\"dateModified\\":\\"2024-12-02T08:08:41.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":10.07,"words":3021},"git":{"updatedTime":1733126921000,"contributors":[{"name":"yuan.ji","email":"yuan.ji@ly.com","commits":1,"avatar":"https://avatars.githubusercontent.com/yuan.ji?v=4","url":"https://github.com/yuan.ji"}]},"autoDesc":true,"filePathRelative":"日常学习/Docker.md","categoryList":[{"id":"9a91b4","sort":10004,"name":"日常学习"}],"bulletin":false}');export{p as comp,c as data};
